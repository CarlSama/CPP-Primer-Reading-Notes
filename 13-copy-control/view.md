## copy-cons(构造)

拷贝控制函数不为explicit

初始化过程
> 直接初始化  string s(d);  // 拷贝构造函数
> 拷贝初始化  string s = d; // 拷贝构造函数(如果有移动构造函数,有时使用移动)

拷贝初始化应用场景:
> 引用方式的参数传递
> 返回非引用类型(产生临时变量)
> insert/push(emplace使用直接初始化)

拷贝构造函数被用来初始化非引用类型参数,如果其参数不是引用类型,那么为了调用拷贝构造函数,我们必须产生实参的拷贝,再次调用拷贝构造函数,陷入无限循环.

## copy-assign(赋值)


## de-cons

析构函数释放对象所使用的资源,并销毁所有非static对象.

构造函数: 列表初始化顺序 -> 函数体
析构函数: 函数体 -> 按初始化的逆序销毁
> 并不直接销毁成员

**隐式的销毁一个内置指针成员不会delete它所指向的对象**
**使用智能指针/函数体内delete**

## 三/五法则

如果一个类需要析构函数,那么它也需要一个拷贝构造函数和拷贝赋值函数.

需要拷贝操作也需要赋值操作,反之亦然.

## 阻止拷贝

Base(Base&) **= delete**; // 阻止拷贝
Base& operator = (const Base&) **= delete**; //阻止赋值

在新标准之前,是通过将拷贝构造函数和赋值构造函数声明为private来阻止.
> 友元仍然能够拷贝(编译不报错).所以我们**只声明不定义**(链接错误).

## 资源管理

可以定义拷贝操作,使类的行为看起来像值或指针(共享).

### 像指针的类

1. 使用shared_ptr来管理资源.拷贝(或赋值)一个shared_ptr会拷贝(或赋值)shared_ptr指向的指针.shared_ptr自己记录共享的用户,当没有用户时,shared_ptr负责释放资源.

2. 可以使用引用计数来直接管理资源.
> 要使用动态分配的空间来实现共享计数器.

## 交换操作

更想使用自己实现的交换指针或引用的swap函数
> using std::swap

## 移动构造函数
 
注意:不能被拷贝-> IO对象,指针

移动构造函数不分配任何新内存,它接管源对象的内存(并非对象的值).
> 对于指针类型,我们接管后设置为nullptr(保证源对象在移动之后处于可析构状态)

在移动操作之后,源对象必须保持有效的,可析构的状态,但是用户不能对其值做任何假设.

### 合成的移动构造函数

如果我们不声明拷贝构造函数或拷贝赋值运算符,编译器**总会**合成.
如果一个类定义了拷贝构造函数,拷贝运算符或者析构函数,编译器不会为它合成移动构造函数和移动赋值运算符.



## 右值引用

&&来获取.只能绑定到即将销毁

标准库的move函数, 我们可以销毁源对象,也可以对它赋值,但是不能使用它的值.
> int && rr = std::move(dd)







